// AUTOGENERATED FILE
// This file was generated from ly-grammar.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface LilypondActionDict<T> extends BaseActionDict<T> {
  File?: (this: NonterminalNode, arg0: IterationNode) => T;
  Clause?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Version?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: IterationNode, arg3: TerminalNode) => T;
  RelativeClause?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: TerminalNode) => T;
  Music?: (this: NonterminalNode, arg0: IterationNode) => T;
  comment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: NonterminalNode | TerminalNode) => T;
  space?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  Component_note?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Component_repeatedNote?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Component_rest?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Component_barline?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Component?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  command?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: NonterminalNode | TerminalNode) => T;
  barline?: (this: NonterminalNode, arg0: TerminalNode) => T;
  note?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode, arg3: IterationNode, arg4: IterationNode, arg5: IterationNode) => T;
  noteName?: (this: NonterminalNode, arg0: TerminalNode) => T;
  repeatedNote?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  accidental_sharp?: (this: NonterminalNode, arg0: TerminalNode) => T;
  accidental_flat?: (this: NonterminalNode, arg0: TerminalNode) => T;
  accidental?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  rest?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  restName_rest?: (this: NonterminalNode, arg0: TerminalNode) => T;
  restName_wholeBarRest?: (this: NonterminalNode, arg0: TerminalNode) => T;
  restName?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  octave?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  octaveUp?: (this: NonterminalNode, arg0: IterationNode) => T;
  octaveDown?: (this: NonterminalNode, arg0: IterationNode) => T;
  fraction?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode, arg2: IterationNode) => T;
  durationScaled?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  duration?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  expression?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode | TerminalNode) => T;
  slur?: (this: NonterminalNode, arg0: TerminalNode) => T;
  variable?: (this: NonterminalNode, arg0: IterationNode) => T;
}

export interface LilypondSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: LilypondActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: LilypondActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: LilypondActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: LilypondActionDict<T>): this;
}

export interface LilypondGrammar extends Grammar {
  createSemantics(): LilypondSemantics;
  extendSemantics(superSemantics: LilypondSemantics): LilypondSemantics;
}

declare const grammar: LilypondGrammar;
export default grammar;

